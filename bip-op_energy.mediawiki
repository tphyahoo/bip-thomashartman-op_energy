<pre>
  BIP: TK
  Layer: Consensus (soft fork)
  Title: OP_ENERGY
  Author: Thomas Hartman <thomashartman1@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ?
  Status: ?
  Type: ?
  Created: 2014-10-01
  License: ?
</pre>

==Abstract==
 
This BIP describes the new opcode OP_ENERGY which measures the price of bitcoin in hashes between two blocks, thus enabling non-custodial energy derivatives trading in bitcoin. 

==Summary==

OP_ENERGY redefines the NOP_TBD1 opcode. It takes two block numbers as arguments.

The price of a single block span, that is, OP_ENERGY n (n+1) is: 

<pre>
satoshis = subsidy (n) + fee (n)
blocktime = timestamp (n+1) - timestamp (n)
hashes  = ( 2 ^ 256 / target (n) ) * ( 600 / blocktime )
price = hashes / satoshis
</pre>

For a multi block span, the price is sum(hashes)/sum(satoshis), summing over the single block spans.

The calculation is done on uint256 integers (same as target).  

Bip113 mediantime is used for timestamps, to guarantee time is always increasing. 

When executed, if any of the following conditions are true, the script interpreter will terminate with an error:

* the stack has less than 2 elements
* either of the 2 arguments is not type compatible with an nlocktime block number, that is, not in the range from 1 to 500,000,000
* second block number is less than or equal to first block number
* second block is in the future
* block distance is greater than sampling limit of 2016 blocks (or some reasonable limit tbd)1 

Otherwise, the price goes on the stack. The stack format for price is uint256, same as target. 

1 As an alternative (or enhancement) to the block distance restriction, vbytes of an OP_ENERGY transaction could be made to depend on block distance. 

==Motivation==

As Bitcoin lets untrusted parties send value over a communications channel, OP_ENERGY lets untrusted parties trade energy derivatives over a communications channel.

The basic contract is a european cash-or-nothing [https://en.wikipedia.org/wiki/Binary_option binary call] on whether some future OP_ENERGY price exceeds some strike. 

todo: use footnote instead of link to wikipedia article on binary options, and footnote as appropriately in other sections

Synthetic versions of derivatives such as vanilla puts, calls, and futures, can be built up out of the binary call primitive.

As fiat prices roughly track energy prices, fiat trading volume can thus be moved off custodial exchanges, making markets more efficient, private, and secure.

Like any bitcoin transaction, OP_ENERGY trades can be cached onto second layer systems such as lightning. 

OP_ENERGY trading is a potentially rich source of miner fee income, securing bitcoin as miners are weaned off block rewards. This would also drive lightning adoption. There may be privacy benefits as well, such as multiparty trades done in mix pools, akin to joinmarket. 

===Intuition===

OP_ENERGY price charts look similar to charts of difficulty and hashrate. However, unlike difficulty, OP_ENERGY is aware of speed of block discovery (as is hashrate). Unlike hashrate, OP_ENERGY also factors in miner revenue, including fees. 

To a lesser but still significant degree, OP_ENERGY price tracks dollar price, because electricity and mining equipment -- both linked to energy --are priced in dollars. If the OP_ENERGY price increases by 100x between two block spans, it costs 100x as much energy to mine a bitcoin, hence 100x as many dollars. To be sure, OP_ENERGY is not perfectly correlated to fiat, but there is correlation enough to be useful for hedging. 

(Todo: make charts of OP_ENERGY vs usd, using real data, to support this.)

Example use case 1: In a fiat centric world, if fiat can buy less bitcoin via direct exchange than via hashes (high fiat price, low OP_ENERGY price), it makes sense for savvy bitcoin accumulators to sell bitcoin for fiat, and rebuy the bitcoin with hashes instead. This explains fiat manias, and can be used to hedge against them. 

Todo: more examples? Hash rental scenario? Power purchase agreements between miners and utilities? 

===Comparison to Similar Proposals===

Existing powswap and OP_DIFFICULTY proposals on dev-bitcoin would allow to speculate on future hashrate. Powswap does not require a protocol change. However, powswap does not measure the true miner price of bitcoin in hashes as it does not include transaction fees, which will some day dominate block reward. (Additionally, there is currently no public specification of powswap.)

===Example OP_ENERGY Prices===

<pre>
Todo:
Give correct numbers, which could also work as test vectors. 
Use uint256 arithmetic. Currently using ieee754 floating points, and rounding to the nearest integer.
Use median time. Currently using using block timestamp.
Give packed uint256 as well as decimal representation.
</pre>

Single block spans: 

* genesis block                 (OP_ENERGY 1 2): 7
* first block of first halving  (OP_ENERGY 210,000 210,001): 3,830,159 
* first block of second halving (OP_ENERGY 420,000 420,001): 700,961,030,332

The 6 order of magnitude change from genesis to first halving reflects the transition to asics, which was a one time event. The 2 order of magnitude change from first to second halving shows hashes more closely tracking energy (and hence fiat) prices. (todo: work on this paragraph, express it more clearly)

Todo: can we look at OP_ENERGY price at point in time where first fiat trade occurred, for a penny or whatever it was? 2010 sometime iirc. I suspect OP_ENERGY price from then to first halving would far exceed the fiat price change, due to asics. But again this is one time thing. Discuss and make it clearer.

500 block spans: 

* first 500 blocks      (OP_ENERGY 1 500): todo
* before first halving  (OP_ENERGY 209,499 209,999): todo
* around first halving  (OP_ENERGY 209,750 210,250): todo
* after first halving   (OP_ENERGY 210,000 210,500): todo
* before second halving (OP_ENERGY 419,499 419,999): todo
* around second halving (OP_ENERGY 419,750 420,250): todo
* after second halving  (OP_ENERGY 420,000 420,500): todo

Todo: chart 500 block OP_ENERGY price for first 500,000 blocks. 

===Bitcoin Transactions For Selling and Settling OP_ENERGY Binary Calls===

Binary sale: Alice (the buyer) and Bob (the seller) agree on terms of a binary call contract: OP_ENERGY block span, settlement, and premium. A sale transaction enforcing these terms is then written interactively by Alice  and Bob, who need not trust each other. In broad outline, Alice and Bob create a multisig address interactively. Each deposits bitcoin to the address, which is locked until settlement. Alice's deposit is the premium. Alice + Bob's combined deposit is the settlement.  (Note: for concreteness, all contracts discussed in this bip have settlement of 10,000 sat.)

Binary Settlement: After the settlement block is reached, the settlement is spendable by Alice if the OP_ENERGY price is over the strike, Bob otherwise. OP_LESSTHAN is used to perform the comparison in script.

===Black Scholes Pricing===

Normalized premium is a probability-like number between 0 and 1, corresponding to unit settlement value.  

By Black Scholes, the normalized premium is the is the negative of a greek-like value I will term strikeD. StrikeD, for strike delta, is the derivative of the vanilla call with respect to strike. (strikeD is distinct from traditional delta, which is the derivative with respect to spot.)

<pre>
Cv = vanilla call price
K = strike price

strikeD = dCv/dK
normalized premium = - strikeD
</pre>

This means that one can price on-chain binaries by looking at strikeD of correlated vanilla options on traditional custodied exchanges.

Equivalently, normalized premium can be derived as follows

<pre>
S = spot price
K = strike price
phi = cumulative distribution function of normal distribution

time_discont = volatility * sqrt( time to settlement ) 
sample_point = ( ln(S/K) / time_discount ) - time_discount / 2
normalized premium = phi ( sample_point ) 
</pre>

todo, write code for above and sanity check that it matches estimatated strikeD

===Real World Binary Pricing Example===

todo: fix this so it is using strikeD instead of regular delta. 

Bob wants to make a market on OP_ENERGY from blocks 647,136 to 648,136, which is 1000 blocks in the future. To do this, he needs to pick a strike, and determine a strikeD for it. 

<pre>
Current date: August 29, 2020 
Current block: 646,136
Next target adjustment: 647,136
Predicted difficulty adjustment, from block times: -4.3%
Predicted target adjustment, from block times: +4.3%
Predicted OP_ENERGY price adjustment, from block times: -4.3%
PRICE_645_646 = OP_ENERGY 645,136 646,136 = TODO, give real number (price of last 1000 blocks, which is known)
</pre> 

Since energy currently trades against fiat, to get a market feel Bob looks at what fiat call prices are available, expiring around September 7. 

<pre>
Block 647,136: around September 7, 2020
On deribit:
  Spot: $11,450
  $11,000 vanilla call deltas
    September 4: 0.76
    September 11: 0.70
    Splitting the difference, September 7 delta guesstimate: 0.73.
  $11,000 is 4% under spot
</pre>

The on-chain predicted OP_ENERGY price adjustment of -4.3% is reasonably in line with deribit's prediction that fiat price is 73% likely to not drop more than 4%. 

So Bob could price a strike of PRICE_645_646 - 4%, on blocks 647,136 to 648,136, at 7300 sat (10,000 * 0.73). 

<pre>
 STRIKE_ALICE_BOB = PRICE_645_646 * 0.96 = (todo, give real number)
</pre>


Note that if target was unchanged but blocks startied coming in 4% faster after 647136, the trade would resolve the same. Which is good, since the real world energy price would be the same. 

Alice, the buyer, is paid the 10,000 sat if 

<pre>
STRIKE_ALICE_BOB < OP_ENERGY 647,136 648,136 
</pre>

Bob would like to earn 1% as a market maker. So he would buy at 0.5% less (7263 sat) and sell at 0.5% more (7336 sat).

I believe this to be a reasonable pricing model, for demonstration purposes. If the bip is adopted, I expect full time and hyper-competitive market markers would use more sophisticated models. 

If Bob can match buyers and sellers for say, a 1 month lock-up period, this is equivalent to earning 1% a month market risk free, and exit-scam risk free, on his bitcoin. So there is a huge incentive to market-make. 

If custodial exchanges offered OP_ENERGY vanilla calls, strikeD on these could be used for pricing the binaries directly, rather than translating from strikeD on vanilla fiat calls. There is profit incentive to do so. Custodial exchanges are natural market makers for OP_ENERGY binaries, because they have first look at the data (in particular strikeD) on their own platforms. Given this edge, it is reasonable to hope that OP_ENERGY derivatives will emerge on custodial exchanges to complement trades happening on chain. 

===Compound Contracts===

The simplest OP_ENERGY contract is the binary call. From Bob's point of view, this is a binary put. 

Two binary calls or puts can be composed and the result is another contract. In fact any two contracts can be composed, yielding a rich structure of possible contracts which can be created and settled as individual units. 

With compound contracts, we can create synthetic versions of derivatives such as vanilla puts and calls, futures, and the like.

===Synthetic Call Example===

Let us create a synthetic vanilla call from ten binary calls, the first of which is from our previous example.

Our vanilla call is composed of ten binary calls, each 10,000 sat, as in the previous example. The binaries have strikes at STRIKE_ALICE_BOB (see above), STRIKE_ALICE_BOB+1%, etc, up to STRIKE_ALICE_BOB+9%. The synthetic vanilla call has expected payoff less than the organic vanilla call if the underlying OP_ENERGY price increases by more than 9%.

This vanilla has a maximum settlement value of 100,000 sat. If the measured price is under STRIKE_ALICE_BOB, Bob sweeps all 100,000 sats. If it is higher than the STRIKE_ALICE_BOB*1.09 cap, Alice gets everything. If the price settles somewhere between, Bob and Alice split the 100,000 sats, with each binary acting like a price tick that decides who should get the settlement coins. So it acts very similarly, but not identically, to an organic call.

Pricing for the synthetic call can be worked out by pricing the component binary calls, as in the previous example, and then adding up all the prices.

The payoff of this call is capped. And it pays off in granular ticks. So the non-custodied synthetic is different from the custodied organic, which pays off smoothly and is not capped. However, by expanding the max price higher and adding more ticks, the synthetic can mock the organic to any desired level of fidelity. The more realistic, the longer the definition in bitcoin script and hence the higher the transaction fee. Fortunately, synthetics can avoid mining fees by using lightning. So, very rich and organic feeling derivatives can be built affordably. 

===Compound Contract Construction=== 

From a bitcoin script point of view, there are a few basic techniques for composing binaries into compound contracts.

* Multiple if/then clauses, one utxo
** one maker, one taker
** easiest to negotiate and coordinate
** works well with 2-party lightning
** cheaper in block space than multiple utxos. If adopted, taproot would make this cheaper still: cost logarithmic in number of ticks rather than linear. 
* Multiple utxos, single if/then clause for each utxo
** many makers and takers (similar feel to coinjoin)
** could work with multi party lightning
** more flexible
* Mix and match: Many utxos, many if/then clauses, many makers and takers
** most flexible
** also most difficult to negotiate and coordinate

All of these techniques create contracts via a single bitcoin transaction. This guarantees alice a set price for the contract. 

Alternatively, Alice may compromise and split the contract she desires into multiple transactions. She loses the single transaction price guarantee, but by shopping around for advantageous prices over a longer period of time she gains flexibility and may ultimately be more profitable. In so doing, Alice shifts from taker into maker role.

=== Buying and Selling Binaries with Lightning (direct channel) === 

In this section, we show how Alice could buy a binary from Bob, and sell it back, using lightning. Neither the buy nor the sell appears on chain, and no mining fees need be paid. For simplicity, we start with the case where Alice has a direct channel with Bob, so we don't need to worry about routing or lightning fees.

We start with Alice having a 40,000 sat dual funded channel with Bob. Each of them has a balance of 20,000 sat. 

<pre>
Alice <- 20,000 20,000 -> Bob
</pre>

We use the pricing example from before, so Alice buys a binary for 7,336 sat. In return, Bob has to lock up 10,000 sat until the target block is mined. 

<pre>
Alice <- (20000 - 7336) ( 10,000 locked settlement ) ( 20,000 + 7,336 - 10,000 ) -> Bob
=> Alice <- 12664 (10,000 locked settlement) 17336 -> Bob
</pre>

Alice still has 12,664 sats of liquidity that she can use to make lightning purchases on this channel. Bob has 17,336 sats of liquidity he can spend through Alice. And 10,000 sats are locked up until the target block is reached. 

Blocks start coming in more slowly, and Alice starts to worry about her position. So she tries to sell the binary back to Bob. Bob agrees to buy the contract back from Alice, for 7263 sat. Since Bob originated the contract in the first places, this erases the contract. The channel how looks like

<pre>
Alice <- (12,664 + 7,263) (17,336 - 7,336 + 10,000) -> Bob
=> Alice <- 19927 20073 => Bob
</pre>

Bob made 73 sats, or 0.73% on the 10,000 sat he had to lock up. And it is just a pristine, ordinary lightning channel again. As far as the world knows, if the channel closed now, no visible trades took place. 

Alternatively, if Bob was not offering Alice an attractive buy back price, Alice could have shopped around with other market makers to sell a 16.9T binaries to, thereby neutralizing the trade she put on with Bob. This results in two lightning channels with sats tied up in the binary. There is less lightning liquidity with this scenario than where Bob let Alice out of her position, but financially there is the same risk profile for Alice, ie no market risk. And Bob got to hold on to the trade that he likes. 

(Todo: give technical justification that this can be done with lightning.)

=== Binaries with Lightning (routing) === 

What if Alice does not have a direct channel with Bob, but wishes to route through Carol? 

This should still work. However, unlike the usual situation for a routing node, Carol has 10,000 sats of liquidity locked up. She will have to be compensated for this with lightning fees. It's similar to paying interest at a bank. 

Todo: flesh out this example. 


==Specification==

Todo: 

* uint256 arithmetic
* binary call sale transaction, on chain
* binary call sale transaction, lightning 
* settlement transactions

==Economic Considerations==

Todo

look at cost of ops (starting with other ops). Is there such a thing?
What should be cost of OP_ENERGY? The greater the span of blocks the more computation, so should this be accounted for? Or is this clipping coupons, and better not to even try. Note that with taproot, there might be no way to know if a transaction contains an OP_ENERGY contract. 

Model a scenario where there is a full 1mb block full of maximally expensive OP_ENERGY price derivate settlements. Is there a DOS attack here?

==Risks==

Todo, needs work: 

Price manipulation scenarios: 

* transaction fees 
* hashrate

Denial of service scenarios:

* cost of computing prices for nodes 
  If current hashes / satoshis calculation is too expensive, perhaps a simpler definition is possible, that still is useful for trading. 
  Ie, sum(prices) instead of sum(hashes)/sum(satoshis) (but conceptually this definition is harder to reason about)

Chain split scenario
* ?

Protocol
* price calculation needs to be very simple and clear, to minimize risk of inconsistent implementation between clients

* other issues?


==Deployment==

Soft fork. 

== Acknowledgements==

Tamas Blummer (RIP), whose OP_DIFFICULTY proposal was the inspiration for this bip. Jeremy Rubin (powswap). 

Everyone who helped on bitcoin-dev (todo). 








