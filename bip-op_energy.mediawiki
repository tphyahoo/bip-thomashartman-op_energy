<pre>
  BIP: TK
  Layer: Consensus (soft fork)
  Title: OP_ENERGY
  Author: Thomas Hartman <thomashartman1@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ?
  Status: ?
  Type: ?
  Created: 2014-10-01
  License: ?
</pre>

==Abstract==
This BIP describes the new opcode OP_ENERGY, which measures the cost to mine a single satoshi between two blocks. This  can be treated as a price, given in hashes, for energy derivative contracts that can be written and settled on chain between untrusting parties, and without requiring an oracle. 

==Summary==

===Units: Converting from Difficulty to Hashes / Chainwork===

Bitcoin difficulty<ref>https://en.bitcoin.it/wiki/Difficulty</ref> is a measure of how many hashes are expected to be needed, to mine a particular block. 

<pre>
hashes(block) = difficulty(block) * genesis_hashes
  where genesis_hashes = 2**32 

chainwork(blockN) = hashes(blockGenesis) + hashes(block2) + ... + hashes(blockN)
</pre>

The bitcoin-cli tool sometimes give summary statistics in difficulty units, and sometimes in hashes. OP_ENERGY always uses hashes.

===Definition of OP_ENERGY===


OP_ENERGY redefines the existing NOP_TBD (to be determined) opcode to give a measure of hashes per satoshi between two blocks. 

To give first some preliminaries, chainwork(blockN) is the total number of hashes that is expected to produce the blockchain ending in blockN. This is a consensus measure that all nodes can access and all nodes agree on.<ref>Bitcoin nodes can look up the chainwork for a block using the bitcoin-cli getblockheader command.</ref>  The average number of hashes, then, expected to be needed to produce blocks from block1 to block2 is chainwork(block2) - chainwork(block1).   

OP_ENERGY is defined as follows.

<pre>
OP_ENERGY block1 block2 = ( hashes / satoshis ) * ( expectedSeconds / seconds ) 
  where 
      hashes = chainwork (block2) - chainwork (block1) 
          where chainwork (block) = expected number of hashes required to produce the block 
      satoshis = chainRevenue(block2) - chainRevenue(block1)
            where chainRevenue(block) = sum of all miner rewards (subsidy + fees) up to this block
      blocks = block2 - block1
      expectedSeconds = 600 * blocks
      seconds = mediantime (block2) - mediantime (block1)
</pre>

Per this formula, higher difficulty makes bitcoin more expensive (in hashes). Higher transaction fees render it cheaper (in hashes). An adjustment factor for hashrate is applied, so an upwards trending hashrate also makes bitcoin more expensive.

All values are translated into uint256 integers (same as chainwork / bits target), and arithmetic is done accordingly. So division is uint256 integer arithmetic, throwing out remainder.

If any of the following conditions are true, the script interpreter will terminate with an error:

* the stack has less than 2 elements
* either of the 2 arguments is not type compatible with an nlocktime block number, that is, not in the range from 1 to 500,000,000
* block2 <= block1
* block2 is in the future

Otherwise, the 4 byte uint256 hash/sat price goes on the stack. 

===OP_ENERGY of Genesis Block===

To give a concrete example, OP_ENERGY 1 2 is 6.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref> 

The OP_ENERGY whitepaper has further information on historical prices, with interpretation and analysis.

==Motivation==

As Bitcoin lets untrusted parties send value over a communications channel, OP_ENERGY lets untrusted parties trade energy derivatives over a communications channel. Rather than price financial instruments in dollars, or bitcoin, OP_ENERGY prices are given in hashes.

The basic contract is a european cash-or-nothing binary call <ref>https://en.wikipedia.org/wiki/Binary_option#Cash-or-nothing_call</ref>
on whether some future OP_ENERGY price exceeds some strike. 

Synthetic versions of derivatives such as vanilla puts, calls, and futures, can be built up out of the binary call primitive.

As fiat prices roughly track energy prices, fiat trading volume can thus be moved off custodial exchanges, making markets more efficient, private, and secure.

OP_ENERGY trading is a potentially rich source of miner income, securing bitcoin as miners are weaned off block rewards.

Like any bitcoin transaction, OP_ENERGY trades can be cached onto second layer systems such as lightning. So high frequency trading is feasible, and affordable. OP_ENERGY market makers would be running lightning nodes, earning lightning fees, and presumably also routing non-OP_ENERGY lightning transactions for additional lightning fee income. 

There may be privacy benefits as well, such as multiparty trades done in mix pools, akin to joinmarket. 

===Intuition===

OP_ENERGY price charts look similar to charts of difficulty and hashrate. However, these are prices of bitcoin in hashes. So miner revenue is also factored in. 

To a lesser but still consequential degree, OP_ENERGY price tracks dollar price. Bcause electricity and mining equipment -- both linked to energy -- are priced in dollars. Modulo hardware efficiency improvements, which will eventually hit diminishing returns, if OP_ENERGY increases by 100x between two block spans, it costs 100x as much energy to mine a bitcoin, hence 100x as many dollars. To be sure, OP_ENERGY price is not perfectly correlated to fiat price (far from it), but there is correlation enough to be useful for hedging. 

(Todo: do r squared regression analysis on OP_ENERGY vs BTCUSD prices, for various lenghts of OP_ENERGY block spans. And make charts of OP_ENERGY price vs usd price, using real data, to support this assertion that OP_ENERGY derivatives would be a useful instrument to hedge BTCUSD.)

===Use Cases===

todo, pretty much everything here needs fleshing out.

====Hedging USD/BTC in crashes and manias====
In a fiat centric world, if fiat can buy less bitcoin via direct exchange than via hashes (high fiat price, low OP_ENERGY price), it makes sense for savvy bitcoin accumulators to sell bitcoin for fiat, and rebuy the bitcoin with hashes instead. This explains fiat manias, and can be used to hedge against them, using OP_ENERGY.

====Hedging power purchasing agreements, for miners====

Megawatt futures rental rental scenario. Power purchase agreements between miners and utilities. 

====Hedging hashrate purchasing agreements, for utilities====

Similar to how large miners have power purchasing agreements from utilities, utilities will some day want hash purchasing agreements from miners, for when they think they will have excess power that will otherwise go to waste. OP_ENERGY can be used to hedge the risk of miscalculating hash purchases.

==Bitcoin Transactions For Writing and Settling OP_ENERGY Binary Calls==

Writing (Buy/Sell): Alice (the buyer) and Bob (the seller) agree on terms of an OP_ENERGY binary call contract: block span (block1 to block2), strike, premium, and settlement. The settlement value is always 10,000 sat by convention in the examples given here, so that only block span, strike, and and premium need vary.

A sale transaction enforcing these terms is written interactively by Alice  and Bob, who need not trust each other. In broad outline, Alice and Bob create a multisig address interactively. Each deposits bitcoin to the address. Alice's deposit is the premium. Alice + Bob's combined deposit is the settlement .  

The script contains an if clause such that the locked settlement value is spendable by Alice if 

<pre>
strike < OP_ENERGY block1 block2 
</pre>

or Bob otherwise.

Settling (Resolution): The settlement transaction is simply for Alice or Bob to spend the now unlocked funds, after the second block is reached.

==More Complicated Stuff==

Pricing, Compound Contracts, HFT

Todo, add better breadcrumbs to whitepaper for these more advanced topics.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref>

==Specification==

Todo: 

* uint256 arithmetic
* binary call sale transaction, on chain
* binary call sale transaction, lightning 
* settlement transactions

<pre>
looks like implementation could start with 

https://github.com/bitcoin/bitcoin/blob/89a8299a14af68c1f96ca1650cbfd4fc2952e77b/src/rpc/mining.cpp
static UniValue GetNetworkHashPS(int lookup, int height) {
  ......
arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;
    int64_t timeDiff = maxTime - minTime;

    return workDiff.getdouble() / timeDiff;
}

add a coouple functions that do the OP_ENERGY math and I think this would do what we need.
</pre>

==Cost to Nodes==

OP_ENERGY can be calculated rapidly and cheaply if validating nodes keep uint256 converted values for mediantime, chainFees, chainSubsidy<ref>ChainSubsidy must be stored rather than computed from the deterministic reward function because miners can (and have<ref>https://medium.com/amberdata/why-the-bitcoin-supply-will-never-reach-21-million-7263e322de1</ref>) underpaid the block reward.</ref>, and chainwork. This is 16 bytes total per block, so the first million blocks will require 16mb additional storage. Not too bad, even for an underpowered node running on a raspi. 

Or, chainFees and chainSubsidy could be combined as a single chainRevenue record, saving 4 bytes. Storing fees and subsidy separately is recommended, as it clears the way for the "More Primitives" approach if adopted in the future. (See "Alternative Approaches" section of this bip.)

==Risks==

===UINT256 Specification Inconsistency===

The specification of uint256 must be very simple and clear, to eliminate inconsistency between clients. 

===Price manipulation ===

Some scenarios will now be explored, where miners attempt to profit by manipulating the OP_ENERGY price via their mining activity. 

These scenarios can generally be mitigated, as we will see.

Mitigation aside, a point in favor of adopting OP_ENERGY, despite potential attacks, is that OP_ENERGY style binary trades could be conducted on normal custodying / centralized exchanges, with a trusted oracle to enforce trades. In this case, miners could  perform all these manipulation strategies, without OP_ENERGY in the protocol. Given this, it can be argued: might as well do OP_ENERGY on chain and have bitcoin benefit from higher hashrate, volume moving off custodying exchanges, and more rapid hyperbitcoinization.

That being stated, let's look at attacks, and mitigations.

====Inclusion of Uneconomic Transactions====

For the purposes of this bip, an uneconomic transaction is a transaction whose primary purpose is other than to move bitcoin cheaply as the market will allow at the speed desired.  Currently (I have no proof of this but seems likely), uneconomic transactions may being mined whose purpose is to manipulate transaction fees higher. In an OP_ENERGY world, uneconomic high-fee transactions could be made to manipulate OP_ENERGY lower.

From an observing node's point of view, an uneconomic transaction can be characterized as a transaction with unnecessarily high fees, which is included in a block without being in the node's mempool. There is no way to know with certainty that a transaction is uneconomic, as opposed to user overpayment error, or that the mempool is propagating slowly. But transactions could receive "suspiciousness" scores according to this metric. 

Miners can short OP_ENERGY and self-mine high-fee uneconomic transactions that they themselves have created and not transmitted, to manipulate the OP_ENERGY hashes/sat price down. Since there is no upper limit on transaction fees, OP_ENERGY can be made arbitrarily low with a single successfully self-mined transaction. Miners with high hashrate, or colluding miners who collectively have high hashrate, thus are well positioned to profit on short OP_ENERGY trades. 

That being said, a lesser version of this problem exists without OP_ENERGY. Miners are already currently incentivized to include uneconomic high-fee transactions, to manipulate transaction fees higher.

There are game theoretic reasons why miners don't in fact manipulate transaction fees -- or are limited in how much manipulation can in practice be done. These reasons and limits apply in an OP_ENERGY world as well.

The primary check on miners' ability to include uneconomic transactions is that once a transaction is in a block, there is the risk of block orphaning and another miner poaching the fee. The more unusually high the fees, the greater the incentive and therefore the higher the risk of poaching. A secondary risk is that nodes may delay confirmation of suspicious blocks which appear to contain uneconomic transactions (unusually high fee, and not seen in mempool), further increasing the orphan risk. No such confirmation delay mechanism is described in the bitcoin white paper. But, nodes control confirmation, not miners. And most economically important nodes want lower fees. In an OP_ENERGY world, economically important nodes would want a fair and smoothly functioning OP_ENERGY market, as they are working as market makers and earning lightning transaction fees. So miners cannot self-mine uneconomic transactions with impunity. This is true today, and would continue to be true if OP_ENERGY went live. 

Let's explore this in more depth. 

Both for current transaction fee manipulation, and in an OP_ENERGY world, the calculus for profitability of cheating by inclusion of uneconomic fees worth txV satoshis, is something like:

<pre>
profit = expectedProfit - expectedLoss
  where expectedProfit = probabilitySuccessfullyMinedBlock * txfeeManipulationRevenue 
        expectedLoss = txLoss + blockLoss + networkTrustDestructionLoss
        txLoss = orphanProbabilityWithManipulation * txV
        blockLoss = orphanProbabilityDelta * (blockRevenue - txV)
        orphanProbabilityDelta = orphanProbabilityWithManipulation - orphanProbabilityWithoutManipulation
        networkTrustDestructionLoss = socialized cost of loss of trust due to miner misbehavior. 
          (Not much can  be said about this hard to measure quantity, other than noting it.)
</pre>

Clearly, OP_ENERGY cheating has potential for greater txfeeManipulationRevenue, than is currently the case with just trying to surreptitiously nudge bitcoin users to pay higher fees. But, OP_ENERGY manipulation is also likely to involve higher txV fees, and be more obviously suspicious. So there is more incentive for fee poaching as well, meaning more risk for cheaters. There is also a higher risk of validating nodes delaying confirmation of suspicious blocks, further raising the poaching risk. Many validating nodes would be economically important OP_ENERGY market makers, after all, who are likely to want to retaliate if they see evidence of OP_ENERGY markets being abused. 

In sum, the incentives already pitting hodling nodes against miners are sufficient to deter the attack.

====Exclusion of Economic Transactions====

Todo, needs work: 

Miners can also short OP_ENERGY and exclude transactions to manipulate the price up. The extreme of this would be to mine empty blocks. Cartels of miners and pools could be formed to make the attack more effective. 

Another attack would be to lower txfee rate by excluding transactions, or in the extreme just mining empty blocks. This attack is not as bad, because it is more expensive to miners than the raising fee attack, and it cannot lower txfee rate arbitrarily within a single block, whereas the fee raising attack can raise fees arbitrarily with a single transaction. So it is believed that already existing penalties are sufficient to stop OP_ENERGY manipulation by lowering transaction fees. 

==== Difficulty Manipulation ====

This is more difficult. Todo, think it through anyway.

====Does Price Manipulation Pose Increased Risk of Chain Split?====

Is there a problem?

Look for OP_ENERGY scenarios where miners are more incentivized to hoard unpublished blocks and/or split the chain, beyond what already exists. I can't think of any, but if I am wrong this could be a reason to abandon OP_ENERGY. 

A starting point could be a low probability, high profit OP_ENERGY trade between a large miner and a speculator, where the miner bets on an unlikely OP_ENERGY measurement and then manipulates hash and/or transaction fees to win the bet. While manipulation is undesirable, I don't see why this would lead to chain splits or other misbehavior to non OP_ENERGY transactions however. 

==Test Vectors and Reference Code==

Todo.

==Deployment==

Soft fork. 

==Alternative Approaches==

===More Primitives===

Rather than supply opcodes for each possible measurement, another approach would be to supply primitives and let traders use these a la carte. For example

<pre>
hashes / satoshis * ( expectedSeconds / seconds ) > strike
</pre>

is equivalent to

<pre>
hashes * expectedSeconds > strike * satoshis * seconds
</pre>

So, to do OP_ENERGY with "a la carte primitives" the following opcodes are recommended

<pre>
OP_HASHES block
OP_MEDIANTIME block
OP_CHAINFEES block (sum of all fees since genesis)
OP_CHAINSUBSIDY block (sum of all subsidy since genesis)
OP_UINT256ADD uint256_1 uint256_2 (for adding fee revenue and subsidy revenue)
OP_UINT256SUBTRACT uint256_1 uint256_2
OP_UINT256MULTIPLY uint256_1 uint256_2
</pre>

If only OP_ENERGY style contracts for miner revenue are desired, OP_CHAINFEES/OP_CHAINSUBSIDY/OP_UINT256ADD could be combined into the single OP_CHAINREVENUE opcode. 

OP_BYTES and OP_VBYTES might also be desirable. These measures would enable speculation on transaction fee rates. 

===More Measures===

There are other possible measures. For instance, one might wish to allow contracts on txfee rate in a range of blocks, or hashes / block (ignoring transaction fewes, or ovarious other things. These could all be added with their own OP measuring code, without enabling additional primitives.

===Pros and Cons===

The single OP_ENERGY approach is preferred in this bip as it is a reasonable schelling point to bootstrap a derivatives market. This is preferred to the the more flexible "more primitives" approach because it requires fewer opcodes, and unifies the market around a single reasonable type of contract. The single opcode approach also saves some bytes on chain. However, if there is strong consensus for the a la carte "more primitives" approach, there is no strong reason not to do so. Potentially OP_ENERGY could be rolled out first, and then if it gains traction the additional a la carte opcodes, and/or more measures, could roll out in a later protocol upgrade. 

todo: Is there another alternative/equivalent implementation of OP_ENERGY, using POWSWAP, along with uint256 arithmetic and OP_REVENUE? Would be good to understand powswap better.

==Comparison to Similar Proposals==

POWSWAP: Enables on-chain speculation in hashrate.<ref>https://powswap.com</ref> Powswap does not require a protocol change. However, powswap is an inferior measure of the price of bitcoin in hashes as it does not include transaction fees, which will some day dominate block reward. So powswap is a good measure of overall energy spend, but not (in the long run) of energy price, which requires a denominator in bitcoin. That being said, I think it would be great to see powswap brought online asap.

todo: is there an issue with powswap, where you need watchtowers? I think I asked on list about this, and jeremy rubin said no and gave an example, but I didn't understand it. (right?)
review this: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018150.html

OP_DIFFICULTY: The initial inspiration for this bip.<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016952.html</ref> Alas, Tamas Blummer passed away before he could produce a concrete specification. 

Discreet Log Contracts: Discreet log contracts enable non-custodial trades, not only in energy derivatives but in any asset.<ref>https://dci.mit.edu/smart-contracts</ref> No protocol change is required. However, trust in an oracle is required, which makes DLC inferior to OP_ENERGY for energy derivatives. That being said, I very much favor DLC for every other type of trading that cannot be trustlessly pegged to hashing, and hope it is developed successfully and sees wide adoption soon. 

== Footnotes ==

<references />

== Acknowledgements==

Tamas Blummer (RIP), whose OP_DIFFICULTY proposal was the inspiration for this bip. Jeremy Rubin (powswap). 

Everyone who helped on bitcoin-dev (todo). 








