<pre>
  BIP: TK
  Layer: Consensus (soft fork)
  Title: OP_ENERGY
  Author: Thomas Hartman <thomashartman1@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ?
  Status: ?
  Type: ?
  Created: 2020-08-31
  License: ?
</pre>

==Abstract==
This BIP describes the new opcode OP_ENERGY, which measures the cost to mine a single satoshi between two blocks. This  can be treated as a price, given in hashes, for energy derivative contracts that can be written and settled on chain between untrusting parties, and without requiring an oracle. 

==Prelude==

===Target, Hashes, Difficulty and Chainwork===

Hashes(block) is the statistically expected number of hashes expected to solve a block with a given target.

<pre>
hashes(block) = 2^256 / target(block)
</pre>

todo: is it 2^256 or 2^256-1 ?

Difficulty(block) <ref>bitcoin-cli todo</ref> is a related measure.

<pre>
difficulty(block) = genesis_target / target(block)
  where genesis_target = todo
</pre>

Hashes can also be expressed in difficulty units:

<pre>
hashes(block) = difficulty(block) * genesis_hashes
  where genesis_hashes = (2^32 - 1)
</pre>

The bitcoin-cli tool subcommands sometimes give summary statistics in difficulty units, and sometimes in hashes. OP_ENERGY always prefers hashes. (todo: make this so, can we actually not mention difficulty again?)

Chainwork(block) <ref>bitcoin-cli getblockheader</ref> is the cumulative hashes statistically expected to reach a certain height in the blockchain.

<pre>
chainwork(blockN) = hashes(block1) + hashes(block2) + ... + hashes(blockN)
</pre>

The number of hashes statistically expected to produce blocks from block1 to block2 is chainwork(block2) - chainwork(block1).

==Summary==

===Calculation of OP_ENERGY===

OP_ENERGY redefines the existing NOP_TBD (to be determined) opcode to give a measure of hashes per satoshi between two blocks. The formula is as follows.

<pre>
OP_ENERGY block1 block2 = ( hashes / satoshis ) * hashrate_adjustment_factor
  where 
      hashes' = chainwork (block2) - chainwork (block1)
            where chainwork is defined above
      hashes = pack_uint256 (hashes')
      satoshis' = chainRevenue(block2) - chainRevenue(block1)
            where chainRevenue(block) = sum of all miner rewards (approved subsidy + fees) up to this block
      satoshis = pack_uint256 (satoshis')
      hashrate_adjustment_factor = expectedSeconds / seconds
      expectedSeconds' = 600 * blocks
      expectedSeconds = int_to_uint256 (expectedSeconds')
      blocks = block2 - block1
      seconds' = median_time_past (block2) - median_time_past (block1)
      seconds = pack_uint256 (seconds')
      median_time_past (block) = median time of previous 11 blocks (block timestamp is required to be greater than this value)
      pack_uint256 = convert a vanilla integer into a bits target style reduced precision uint256 integer.
      / = uint256 division
      * = uint256 multiplication
</pre>

Per this formula, higher difficulty makes bitcoin more expensive (measured in hashes). Higher transaction fees render it cheaper (in hashes).

The expectedSeconds / seconds term is an adjustment factor for hashrate, so an upwards trending hashrate makes bitcoin more expensive, and lower trending cheaper. Note that seconds, the denominator, is guaranteed to be nonzero, as the 11 block median time past increases with every block. This is because, per protocol rules, the block time stamp must be greater than the block median time past <ref>todo</ref>.

The subsidy part of the miner reward is the protocol approved subsidy, which can be computed from the block number. (Actual subsidy differs from this by a few satoshis, presumably due to miner error.<ref>https://medium.com/amberdata/why-the-bitcoin-supply-will-never-reach-21-million-7263e322de1</ref>)  (todo, does this discrepancy matter to OP_ENERGY. double check.) This value is already calculated by bitcoind on a per-block basis, via the command todo.

All values are translated into arith_uint256 integers (same as bits target), and arithmetic is done accordingly. 

===OP_ENERGY of Genesis Block===

To give a concrete example, OP_ENERGY 1 2 is 6.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref> The OP_ENERGY measurement at the start of bitcoin was that 6 hashes per satoshi were required.  

The OP_ENERGY whitepaper has further information on historical prices, with interpretation and analysis.

===Script Interpreter Behavior===

If any of the following conditions are true, the script interpreter will terminate with an error:

* the stack has less than 2 elements
* either of the 2 arguments is not type compatible with an nlocktime block number, that is, not in the range from 1 to 500,000,000
* block2 <= block1
* block2 + 100 > blockchain tip (same 100 block burying condition as for spending miner rewards, see whitepaper for more)

Otherwise, the 4 byte uint256 computed value goes on the stack. 

===Penalization of Uneconomic Transactions===

To do

==Motivation==

As Bitcoin lets untrusted parties send value over a communications channel, OP_ENERGY lets untrusted parties trade energy derivatives over a communications channel. Rather than price financial instruments in dollars, or bitcoin, OP_ENERGY prices are given in hashes.

The basic contract is a european cash-or-nothing binary call <ref>https://en.wikipedia.org/wiki/Binary_option#Cash-or-nothing_call</ref>
on whether some future OP_ENERGY price exceeds some strike. 

Fair prices for OP_ENERGY binaries can be determined using techniques such as black scholes, as is done by market makers on many existing binary exchanges. (Whitepaper: pricing) 

OP_ENERGY settlements are less prone to abuse than binaries on existing centralized binary exchanges, as settlement prices are derived from consensus bitcoin data. 

Synthetic versions of derivatives such as vanilla puts, calls, and futures, can be built up out of the binary call primitive. (whitepaper: compound contracts)

As fiat prices roughly track energy prices, fiat trading volume can thus be moved off custodial exchanges, making markets more efficient, private, and secure.

OP_ENERGY trading is a potentially rich source of miner income, securing bitcoin as miners are weaned off block rewards.

Like any bitcoin transaction, OP_ENERGY trades can be cached onto second layer systems such as lightning. So high frequency trading is feasible, and affordable. OP_ENERGY market makers would be running lightning nodes, earning lightning fees, and presumably also routing non-OP_ENERGY lightning transactions for additional lightning fee income. (whitepaper: HFT)

There may be privacy benefits as well, such as multiparty trades done in mix pools, akin to joinmarket.

Many concrete use cases are given in the whitepaper.

==Intuition==

OP_ENERGY price charts look similar to charts of difficulty and hashrate. However, these are prices of bitcoin in hashes. So miner revenue is also factored in. 

To a lesser but still consequential degree, OP_ENERGY price tracks dollar price. Bcause electricity and mining equipment -- both linked to energy -- are priced in dollars. Modulo hardware efficiency improvements, which will eventually hit diminishing returns, if OP_ENERGY increases by 100x between two block spans, it costs 100x as much energy to mine a bitcoin, hence 100x as many dollars. To be sure, OP_ENERGY price is not perfectly correlated to fiat price (far from it), but there is correlation enough to be useful for hedging. 

(Todo: do r squared regression analysis on OP_ENERGY vs BTCUSD prices, for various lenghts of OP_ENERGY block spans. And make charts of OP_ENERGY price vs usd price, using real data, to support this assertion that OP_ENERGY derivatives would be a useful instrument to hedge BTCUSD.)

==Bitcoin Transactions For Writing and Settling OP_ENERGY Binary Calls==

Writing (Buy/Sell): Alice (the buyer) and Bob (the seller) agree on terms of an OP_ENERGY binary call contract: block span (block1 to block2), strike, premium, and settlement. The settlement value is always 10,000 sat by convention in the examples given here, so that only block span, strike, and and premium need vary.

A sale transaction enforcing these terms is written interactively by Alice  and Bob, who need not trust each other. In broad outline, Alice and Bob create a multisig address interactively. Each deposits bitcoin to the address. Alice's deposit is the premium. Alice + Bob's combined deposit is the settlement .  

The script contains an if clause such that the locked settlement value is spendable by Alice if 

<pre>
strike < OP_ENERGY block1 block2 
</pre>

or Bob otherwise.

Settling (Resolution): The settlement transaction is simply for Alice or Bob to spend the now unlocked funds, after the second block is reached.

==Alternative Approaches, Comparison to Similar Proposals==

see whitepaper

==Specification==

Todo: 

* uint256 arithmetic
* binary call sale transaction, on chain
* binary call sale transaction, lightning 
* settlement transactions

<pre>
looks like implementation could start with 

https://github.com/bitcoin/bitcoin/blob/89a8299a14af68c1f96ca1650cbfd4fc2952e77b/src/rpc/mining.cpp
static UniValue GetNetworkHashPS(int lookup, int height) {
  ......
arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;
    int64_t timeDiff = maxTime - minTime;

    return workDiff.getdouble() / timeDiff;
}

add a coouple functions that do the OP_ENERGY math and I think this would do what we need.
</pre>

==Risks==

See whitepaper<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref>.

==Test Vectors and Reference Code==

Todo.

Initial thoughts for tests... 

* uint256 stuff
* check some empty blocks, in early times when approved subsidy = actual subsidy. The OP_ENERGY should depend on only the computed subsidy, and the mediantimes. 
* actual reward, versus approved subsidy (should be approved subsidy). Check block spans where approved does not equal actual subsidy
* hardcode historical prices from whitepaper, check these in tests

==Deployment==

Soft fork. 

== Footnotes ==

<references />

== Acknowledgements==

Tamas Blummer (RIP), whose OP_DIFFICULTY proposal was the inspiration for this bip. Jeremy Rubin (powswap). 

Everyone who helped on bitcoin-dev (todo). 








