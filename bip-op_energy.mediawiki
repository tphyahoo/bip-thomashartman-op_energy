<pre>
  BIP: TK
  Layer: Consensus (soft fork)
  Title: OP_ENERGY
  Author: Thomas Hartman <thomashartman1@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ?
  Status: ?
  Type: ?
  Created: 2020-08-31
  License: ?
</pre>

==Abstract==
This BIP describes the new opcode OP_ENERGY, which measures the mining energy cost in hashes per satoshi between two blocks. This can be treated as a price, given in hashes, for energy derivative contracts that can be written and settled between untrusting parties. 

==Prelude==

===Target, Hashes, Difficulty and Chainwork===

Chainwork(block) is the cumulative hashes statistically expected to reach a certain height in the blockchain. This is a key consensus value, used to determine which blockchain is most valuable when there are conflicts at the tip. 

<pre>
chainwork(blockN) = blockwork(block0) + blockwork(block1) + ... + blockwork(blockN)
</pre>

Blockwork(block) is the statistically expected number of hashes required to solve a block.<ref>Defined in the bitcoin core reference client, in GetBlockProof</ref>. 

<pre>
blockwork(block) = 2^256 `div` ( target(block) + 1 )
  where `div` = integer division
</pre>


Target(block) is the way the work (in hashes) required of a block is recorded in the bitcoin block header.

An important constant is the target of the genesis block:

<pre>
genesis_target = target(0) = 0xffff * 2^208
</pre>

With this, we can calculate the blockwork of the genesis block:

<pre>
genesis_blockwork = blockwork(0) = 2^256 `div` ((0xffff * 2^208)) + 1) = 0x100010001 
  (approximately 2^32)
</pre>

Difficulty(block) is a floating point measure of how much more expensive (in hashes) blocks have become since genesis.

<pre>
difficulty(block) = genesis_target / target(block)
  where / = floating point division
</pre>

Blockwork can also be expressed in difficulty units, allowing for some imprecision due to the complexities of float. IE: 

<pre>
blockwork(block) =~ difficulty(block) * genesis_blockwork
</pre>

The bitcoin-cli tool subcommands sometimes give summary statistics for work in difficulty units, and sometimes in hashes. To avoid the complexities of floating point numbers, OP_ENERGY always prefers hashes, which is defined using integers and integer division.

=== Hashes Between Two Blocks === 

As the definition of chainwork above should make clear, the total number of hashes statistically expected to have produced blocks from block1 to block2 is 

<pre>
hashes block1 block2 = chainwork(block2) - chainwork(block1)
</pre>

To make this calculation easy, a running total of chainwork for each block can be stored. 

=== Miner Revenue Between Two Blocks === 

The total number of satoshis earned by miners from block1 to block2 is 

<pre>
satoshis block1 block2 = chainRevenue(block2) - chainRevenue(block1)
            where chainRevenue is sum of all miner rewards (subsidy + fees) up to this block
</pre>

As with chainwork, it would be reasonable to store a running total of chainRevenue to facilitate such calculations. 

Note that the subsidy part of the miner reward is the protocol approved subsidy, which can be looked up from the block number. Actual subsidy differs from this by a few satoshis, presumably due to miner error <ref>https://medium.com/amberdata/why-the-bitcoin-supply-will-never-reach-21-million-7263e322de1</ref>.


=== Price of Satoshis in Hashes Between Two Blocks === 

If we view mining as buying satoshis with hashes, then the price of a satoshi between two blocks could be defined as 

<pre>
hashes_per_satoshi block1 block2 = (hashes block1 block2) / (satoshis block1 block2)
  where hashes   block1 block2 = chainwork(block2) - chainwork(block1)
        satoshis block1 block2 = chainRevenue(block2) - chainRevenue(block1)
<pre>

with chainwork and chainRevenue as defined above.

===Blocktime Dampening Between Two Blocks===

A thermostat provides negative feedback -- i.e. dampening -- to a climate control system with the objective of keeping a room at a desired temperature, say 72 degrees.  A cruise control system provides dampening feedback to a vehicle to keep it moving at a desired velocity, say 60 miles per hour. Likewise, the bitcoin protocol provides dampening to fix miner productivity at 600 seconds per block.  The mechanism to accomplish this is to adjust the blockwork every epoch (2016 blocks). <ref>https://en.bitcoin.it/wiki/Difficulty#What_network_hash_rate_results_in_a_given_difficulty.3F</ref>

If average seconds per block in a given epoch is under 600 (too fast), blockwork is too low, i.e. blocks are too cheap priced in hashes and the blockwork needs to be raised. Blocks could also be too expensive (too slow), in which case blocktime_dampening_factor would lower the cost of a block in hashes.

<pre>
blockwork (new_epoch) = blockwork (previous_epoch) * blocktime_dampening_factor (previous_epoch)

blocktime_dampening_factor(epoch) = expectedSeconds / actualSeconds
  where expectedSeconds = 600 * blocks 
        blocks = 2016 
        actualSeconds = timestamp(lastBlock in epoch) - timestamp(first block in epoch)  
</pre>

todo: are timestamps block timestamps or median time past values?

The above formula defines the protocol blocktime dampening for one of the 2016 block difficulty epochs. 

OP_ENERGY generalizes this to define the dampening factor for any span of blocks. 

<pre>
blocktime_dampening_factor block1 block2 = expectedSeconds / actualSeconds
  where expectedSeconds = 600 * blocks
        blocks = block2 - block1
        actualSeconds = timestamp(block2) - timestamp(block1)
</pre>

The blocktime_dampening_factor is thus a concrete meausure of whether the bitcoin protocol wants a future rise or fall in blockwork required when looking at some region of blocks.

=== OP_ENERGY: The Dampened Price of Satoshis in Hashes Between Two Blocks === 

This leads to a definition of the op_energy price, morally, as 

<pre>
op_energy_price block1 block2 = (hashes_per_satoshi block1 block2) * (blocktime_dampening_factor block1 block2)
</pre>

If reward halvings and transaction fees are excluded, the following holds for consecutive epochs: 

<pre>
hashes_per_satoshi (epoch + 1) = hashes_per_satoshi (epoch) * blocktime_dampening_factor (epoch)
</pre>

This is equivalent to:

<pre>
op_energy_price (epoch) = hashes_per_satoshi (epoch + 1) 
</pre

Viewing arbitrary block span OP_ENERGY as a generalization of the above formula, we have then an interpretation of OP_ENERGY as an expected future hashes_per_satoshi price, which utilizes all information available to the bitcoin protocol.

==Summary==

===Calculation of OP_ENERGY===

OP_ENERGY redefines the existing NOP_TBD (to be determined) opcode to give a protocol price in hashes per satoshi between two blocks, which accounts for speedup or slowdown in block discovery times.

The exact definition is: 

<pre>
OP_ENERGY_PRICE block1 block2 = pack_uint256 price'
  where 
      price' = ( ( hashes `div` satoshis ) * expectedSeconds ) `div` actualSeconds 
      hashes = chainwork (block2) - chainwork (block1)
      satoshis = chainRevenue(block2) - chainRevenue(block1)
            where chainRevenue is sum of all miner rewards (subsidy + fees) up to this block
      expectedSeconds = 600 * (block2 - block1)
      actualSeconds = median_time_past (block2) - median_time_past (block1)
        where median_time_past is median time of previous 11 blocks as defined in bip 113
      pack_uint256 = compress a uint256 integer into 32 bits, using same compression as cbits in block header.
      div = integer division
</pre>

Unless otherwise noted, all values in the above calculation are ordinary integers.<ref>=Due to the cbits packing in the last step, this could technically overflow if price' overflows 2^256, but this seems to be impossible given that bitcoin is already using on the order of 0.1% of global energy and is thus unlikely to rise more than 1000x. A great many orders of magnitude more than 1000x would be required for the overflow issue to arise.</ref> 

It's also worth noting that actualSeconds is guaranteed to be positive, as the 11 block median time past increases with every block. This is because, per protocol rules, the block time stamp must be greater than the block median time past <ref>https://en.bitcoin.it/wiki/Block_timestamp</ref>.

===OP_ENERGY of Genesis Block===

To give a concrete example, OP_ENERGY 1 2 is 6.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref> The OP_ENERGY measurement at the start of bitcoin was that 6 hashes per satoshi were required.  

The OP_ENERGY whitepaper has further information on historical prices, with interpretation and analysis.

===Script Interpreter Behavior===

If any of the following conditions are true, the script interpreter will terminate with an error:

* the stack has less than 2 elements
* either of the 2 arguments is not type compatible with an nlocktime block number, that is, not in the range from 1 to 500,000,000
* block2 <= block1
* block2 >= blockchain tip -100 (same 100 block burying condition as for spending miner rewards, see whitepaper for why) (this only applies to spending transactions) (todo: explain how)

Otherwise, the 4 byte uint256 computed value goes on the stack. 

===Penalization of Uneconomic Transactions===

To do

==Motivation==

As Bitcoin lets untrusted parties send value over a communications channel, OP_ENERGY lets untrusted parties trade energy derivatives over a communications channel. Rather than price financial instruments in dollars, or bitcoin, OP_ENERGY prices are given in hashes.

The basic contract is a european cash-or-nothing binary call <ref>https://en.wikipedia.org/wiki/Binary_option#Cash-or-nothing_call</ref>
on whether some future OP_ENERGY price exceeds some strike. 

Fair prices for OP_ENERGY binaries can be determined using techniques such as black scholes, as is done by market makers on many existing binary exchanges. (Whitepaper: pricing) 

OP_ENERGY settlements are less prone to abuse than binaries on existing centralized binary exchanges, as settlement prices are derived from consensus bitcoin data. 

Synthetic versions of derivatives such as vanilla puts, calls, and futures, can be built up out of the binary call primitive. (whitepaper: compound contracts)

As fiat prices roughly track energy prices, fiat trading volume can thus be moved off custodial exchanges, making markets more efficient, private, and secure.

OP_ENERGY trading is a potentially rich source of miner income, securing bitcoin as miners are weaned off block rewards.

Like any bitcoin transaction, OP_ENERGY trades can be cached onto second layer systems such as lightning. So high frequency trading is feasible, and affordable. OP_ENERGY market makers would be running lightning nodes, earning lightning fees, and presumably also routing non-OP_ENERGY lightning transactions for additional lightning fee income. (whitepaper: HFT)

There may be privacy benefits as well, such as multiparty trades done in mix pools, akin to joinmarket.

Many concrete use cases are given in the whitepaper.

==Intuition==

To a miner, OP_ENERGY is the price of a satoshi, in hashes. So OP_ENERGY time series charts look somewhat similar to hashrate charts. 

To a lesser but still consequential degree, OP_ENERGY price tracks dollar price. Bcause electricity and mining equipment -- both linked to energy -- are priced in dollars. Modulo hardware efficiency improvements, which will eventually hit diminishing returns, if OP_ENERGY increases by 100x between two block spans, it costs 100x as much energy to mine a bitcoin, hence 100x as many dollars. To be sure, OP_ENERGY price is not perfectly correlated to fiat price (far from it), but there is correlation enough to be useful for hedging. 

The whitepaper has more on op_energy price correlation to usd price.

==Bitcoin Transactions For Writing and Settling OP_ENERGY Binary Calls==

Writing (Buy/Sell): Alice (the buyer) and Bob (the seller) agree on terms of an OP_ENERGY binary call contract: block span (block1 to block2), strike, premium, and settlement. The settlement value is always 10,000 sat by convention in the examples given here, so that only block span, strike, and and premium need vary.

A sale transaction enforcing these terms is written interactively by Alice  and Bob, who need not trust each other. In broad outline, Alice and Bob create a multisig address interactively. Each deposits bitcoin to the address. Alice's deposit is the premium. Alice + Bob's combined deposit is the settlement .  

The script contains an if clause such that the locked settlement value is spendable by Alice if 

<pre>
strike < OP_ENERGY block1 block2 
</pre>

or Bob otherwise.

Settling (Resolution): The settlement transaction is simply for Alice or Bob to spend the now unlocked funds, after the second block is reached.

==Alternative Approaches, Comparison to Similar Proposals==

see whitepaper

==Specification==

Todo: 

* uint256 arithmetic
* write binary call, on chain
* settle binary call, on chain
* write and settle binary call, lightning 

<pre>
looks like implementation could start with 

https://github.com/bitcoin/bitcoin/blob/89a8299a14af68c1f96ca1650cbfd4fc2952e77b/src/rpc/mining.cpp
static UniValue GetNetworkHashPS(int lookup, int height) {
  ......
arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;
    int64_t timeDiff = maxTime - minTime;

    return workDiff.getdouble() / timeDiff;
}

add a coouple functions that do the OP_ENERGY math and I think this would do what we need.
</pre>

==Risks==

See whitepaper<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref>.

==Test Vectors and Reference Code==

Todo.

Initial thoughts for tests... 

* uint256 stuff
* check some empty blocks, in early times when approved subsidy = actual subsidy. The OP_ENERGY should depend on only the computed subsidy, and the mediantimes. 
* for actual subsidy, versus subsidy claimed, should be approved subsidy. Check block spans where approved does not equal actual subsidy <ref>https://medium.com/amberdata/why-the-bitcoin-supply-will-never-reach-21-million-7263e322de1</ref>.
* hardcode historical prices from whitepaper, check these in tests

==Deployment==

Soft fork. 

== Footnotes ==

<references />

== Acknowledgements==

Tamas Blummer (RIP), whose OP_DIFFICULTY proposal was the inspiration for this bip. Jeremy Rubin (powswap). 







