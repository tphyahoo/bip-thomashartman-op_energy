<pre>
  BIP: TK
  Layer: Consensus (soft fork)
  Title: OP_ENERGY
  Author: Thomas Hartman <thomashartman1@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ?
  Status: ?
  Type: ?
  Created: 2014-10-01
  License: ?
</pre>

==Abstract==
This BIP describes the new opcode OP_ENERGY, which measures the cost to mine a single satoshi between two blocks. This  can be treated as a price, given in hashes, for energy derivative contracts that can be written and settled on chain between untrusting parties, and without requiring an oracle. 

==Summary==

===Units: Converting from Difficulty to Hashes / Chainwork===

Bitcoin difficulty<ref>https://en.bitcoin.it/wiki/Difficulty</ref> is a measure of how many hashes are expected to be needed, to mine a particular block. 

<pre>
hashes(block) = difficulty(block) * genesis_hashes
  where genesis_hashes = 2**32 

chainwork(blockN) = hashes(blockGenesis) + hashes(block2) + ... + hashes(blockN)
</pre>

The bitcoin-cli tool sometimes give summary statistics in difficulty units, and sometimes in hashes. OP_ENERGY always uses hashes.

===Definition of OP_ENERGY===


OP_ENERGY redefines the existing NOP_TBD (to be determined) opcode to give a measure of hashes per satoshi between two blocks. 

To give first some preliminaries, chainwork(blockN) is the total number of hashes that is expected to produce the blockchain ending in blockN. This is a consensus measure that all nodes can access and all nodes agree on.<ref>Bitcoin nodes can look up the chainwork for a block using the bitcoin-cli getblockheader command.</ref>  The average number of hashes, then, expected to be needed to produce blocks from block1 to block2 is chainwork(block2) - chainwork(block1).   

OP_ENERGY is defined as follows.

<pre>
OP_ENERGY block1 block2 = ( hashes / satoshis ) * ( expectedSeconds / seconds ) 
  where 
      hashes = chainwork (block2) - chainwork (block1) 
          where chainwork (block) = expected number of hashes required to produce the block 
      satoshis = chainRevenue(block2) - chainRevenue(block1)
            where chainRevenue(block) = sum of all miner rewards (subsidy + fees) up to this block
      blocks = block2 - block1
      expectedSeconds = 600 * blocks
      seconds = mediantime (block2) - mediantime (block1)
</pre>

Per this formula, higher difficulty makes bitcoin more expensive (in hashes). Higher transaction fees render it cheaper (in hashes). An adjustment factor for hashrate is applied, so an upwards trending hashrate also makes bitcoin more expensive.

All values are translated into uint256 integers (same as chainwork / bits target), and arithmetic is done accordingly. So division is uint256 integer arithmetic, throwing out remainder.

If any of the following conditions are true, the script interpreter will terminate with an error:

* the stack has less than 2 elements
* either of the 2 arguments is not type compatible with an nlocktime block number, that is, not in the range from 1 to 500,000,000
* block2 <= block1
* block2 is in the future

Otherwise, the 4 byte uint256 hash/sat price goes on the stack. 

===OP_ENERGY of Genesis Block===

To give a concrete example, OP_ENERGY 1 2 is 6.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref> The OP_ENERGY measurement at the start of bitcoin was that 6 hashes per satoshi were required.  

The OP_ENERGY whitepaper has further information on historical prices, with interpretation and analysis.

==Motivation==

As Bitcoin lets untrusted parties send value over a communications channel, OP_ENERGY lets untrusted parties trade energy derivatives over a communications channel. Rather than price financial instruments in dollars, or bitcoin, OP_ENERGY prices are given in hashes.

The basic contract is a european cash-or-nothing binary call <ref>https://en.wikipedia.org/wiki/Binary_option#Cash-or-nothing_call</ref>
on whether some future OP_ENERGY price exceeds some strike. 

Synthetic versions of derivatives such as vanilla puts, calls, and futures, can be built up out of the binary call primitive.

As fiat prices roughly track energy prices, fiat trading volume can thus be moved off custodial exchanges, making markets more efficient, private, and secure.

OP_ENERGY trading is a potentially rich source of miner income, securing bitcoin as miners are weaned off block rewards.

Like any bitcoin transaction, OP_ENERGY trades can be cached onto second layer systems such as lightning. So high frequency trading is feasible, and affordable. OP_ENERGY market makers would be running lightning nodes, earning lightning fees, and presumably also routing non-OP_ENERGY lightning transactions for additional lightning fee income. 

There may be privacy benefits as well, such as multiparty trades done in mix pools, akin to joinmarket. 

===Intuition===

OP_ENERGY price charts look similar to charts of difficulty and hashrate. However, these are prices of bitcoin in hashes. So miner revenue is also factored in. 

To a lesser but still consequential degree, OP_ENERGY price tracks dollar price. Bcause electricity and mining equipment -- both linked to energy -- are priced in dollars. Modulo hardware efficiency improvements, which will eventually hit diminishing returns, if OP_ENERGY increases by 100x between two block spans, it costs 100x as much energy to mine a bitcoin, hence 100x as many dollars. To be sure, OP_ENERGY price is not perfectly correlated to fiat price (far from it), but there is correlation enough to be useful for hedging. 

(Todo: do r squared regression analysis on OP_ENERGY vs BTCUSD prices, for various lenghts of OP_ENERGY block spans. And make charts of OP_ENERGY price vs usd price, using real data, to support this assertion that OP_ENERGY derivatives would be a useful instrument to hedge BTCUSD.)

===Use Cases===

todo, pretty much everything here needs fleshing out.

====Hedging USD/BTC in crashes and manias====
In a fiat centric world, if fiat can buy less bitcoin via direct exchange than via hashes (high fiat price, low OP_ENERGY price), it makes sense for savvy bitcoin accumulators to sell bitcoin for fiat, and rebuy the bitcoin with hashes instead. This explains fiat manias, and can be used to hedge against them, using OP_ENERGY.

====Hedging power purchasing agreements, for miners====

Megawatt futures rental rental scenario. Power purchase agreements between miners and utilities. 

====Hedging hashrate purchasing agreements, for utilities====

Similar to how large miners have power purchasing agreements from utilities, utilities will some day want hash purchasing agreements from miners, for when they think they will have excess power that will otherwise go to waste. OP_ENERGY can be used to hedge the risk of miscalculating hash purchases.

==Bitcoin Transactions For Writing and Settling OP_ENERGY Binary Calls==

Writing (Buy/Sell): Alice (the buyer) and Bob (the seller) agree on terms of an OP_ENERGY binary call contract: block span (block1 to block2), strike, premium, and settlement. The settlement value is always 10,000 sat by convention in the examples given here, so that only block span, strike, and and premium need vary.

A sale transaction enforcing these terms is written interactively by Alice  and Bob, who need not trust each other. In broad outline, Alice and Bob create a multisig address interactively. Each deposits bitcoin to the address. Alice's deposit is the premium. Alice + Bob's combined deposit is the settlement .  

The script contains an if clause such that the locked settlement value is spendable by Alice if 

<pre>
strike < OP_ENERGY block1 block2 
</pre>

or Bob otherwise.

Settling (Resolution): The settlement transaction is simply for Alice or Bob to spend the now unlocked funds, after the second block is reached.

==More Complicated Stuff==

Pricing, Compound Contracts, HFT

Todo, add better breadcrumbs to whitepaper for these more advanced topics.<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref>

==Specification==

Todo: 

* uint256 arithmetic
* binary call sale transaction, on chain
* binary call sale transaction, lightning 
* settlement transactions

<pre>
looks like implementation could start with 

https://github.com/bitcoin/bitcoin/blob/89a8299a14af68c1f96ca1650cbfd4fc2952e77b/src/rpc/mining.cpp
static UniValue GetNetworkHashPS(int lookup, int height) {
  ......
arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;
    int64_t timeDiff = maxTime - minTime;

    return workDiff.getdouble() / timeDiff;
}

add a coouple functions that do the OP_ENERGY math and I think this would do what we need.
</pre>

==Cost to Nodes==

OP_ENERGY can be calculated rapidly and cheaply if validating nodes keep uint256 converted values for mediantime, chainFees, chainSubsidy<ref>ChainSubsidy must be stored rather than computed from the deterministic reward function because miners can (and have<ref>https://medium.com/amberdata/why-the-bitcoin-supply-will-never-reach-21-million-7263e322de1</ref>) underpaid the block reward.</ref>, and chainwork. This is 16 bytes total per block, so the first million blocks will require 16mb additional storage. Not too bad, even for an underpowered node running on a raspi. 

Or, chainFees and chainSubsidy could be combined as a single chainRevenue record, saving 4 bytes. Storing fees and subsidy separately is recommended, as it clears the way for the "More Primitives" approach if adopted in the future. (See "Alternative Approaches" section of this bip.)

==Risks==

See whitepaper<ref>https://github.com/tphyahoo/bip-thomashartman-op_energy/blob/master/OP_ENERGY_Whitepaper.mediawiki</ref>.

==Test Vectors and Reference Code==

Todo.

==Deployment==

Soft fork. 

==Alternative Approaches==

===More Primitives===

Rather than supply opcodes for each possible measurement, another approach would be to supply primitives and let traders use these a la carte. For example

<pre>
hashes / satoshis * ( expectedSeconds / seconds ) > strike
</pre>

is equivalent to

<pre>
hashes * expectedSeconds > strike * satoshis * seconds
</pre>

So, to do OP_ENERGY with "a la carte primitives" the following opcodes are recommended

<pre>
OP_HASHES block
OP_MEDIANTIME block
OP_CHAINFEES block (sum of all fees since genesis)
OP_CHAINSUBSIDY block (sum of all subsidy since genesis)
OP_UINT256ADD uint256_1 uint256_2 (for adding fee revenue and subsidy revenue)
OP_UINT256SUBTRACT uint256_1 uint256_2
OP_UINT256MULTIPLY uint256_1 uint256_2
</pre>

If only OP_ENERGY style contracts for miner revenue are desired, OP_CHAINFEES/OP_CHAINSUBSIDY/OP_UINT256ADD could be combined into the single OP_CHAINREVENUE opcode. 

OP_BYTES and OP_VBYTES might also be desirable. These measures would enable speculation on transaction fee rates. 

===More Measures===

There are other possible measures. For instance, one might wish to allow contracts on txfee rate in a range of blocks, or hashes / block (ignoring transaction fewes, or ovarious other things. These could all be added with their own OP measuring code, without enabling additional primitives.

===Pros and Cons===

The single OP_ENERGY approach is preferred in this bip as it is a reasonable schelling point to bootstrap a derivatives market. This is preferred to the the more flexible "more primitives" approach because it requires fewer opcodes, and unifies the market around a single reasonable type of contract. The single opcode approach also saves some bytes on chain. However, if there is strong consensus for the a la carte "more primitives" approach, there is no strong reason not to do so. Potentially OP_ENERGY could be rolled out first, and then if it gains traction the additional a la carte opcodes, and/or more measures, could roll out in a later protocol upgrade. 

todo: Is there another alternative/equivalent implementation of OP_ENERGY, using POWSWAP, along with uint256 arithmetic and OP_REVENUE? Would be good to understand powswap better.

==Comparison to Similar Proposals==

POWSWAP: Enables on-chain speculation in hashrate.<ref>https://powswap.com</ref> Powswap does not require a protocol change. However, powswap is an inferior measure of the price of bitcoin in hashes as it does not include transaction fees, which will some day dominate block reward. So powswap is a good measure of overall energy spend, but not (in the long run) of energy price, which requires a denominator in bitcoin. That being said, I think it would be great to see powswap brought online asap.

todo: is there an issue with powswap, where you need watchtowers? I think I asked on list about this, and jeremy rubin said no and gave an example, but I didn't understand it. (right?)
review this: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018150.html

OP_DIFFICULTY: The initial inspiration for this bip.<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016952.html</ref> Alas, Tamas Blummer passed away before he could produce a concrete specification. 

Discreet Log Contracts: Discreet log contracts enable non-custodial trades, not only in energy derivatives but in any asset.<ref>https://dci.mit.edu/smart-contracts</ref> No protocol change is required. However, trust in an oracle is required, which makes DLC inferior to OP_ENERGY for energy derivatives. That being said, I very much favor DLC for every other type of trading that cannot be trustlessly pegged to hashing, and hope it is developed successfully and sees wide adoption soon. 

== Footnotes ==

<references />

== Acknowledgements==

Tamas Blummer (RIP), whose OP_DIFFICULTY proposal was the inspiration for this bip. Jeremy Rubin (powswap). 

Everyone who helped on bitcoin-dev (todo). 








