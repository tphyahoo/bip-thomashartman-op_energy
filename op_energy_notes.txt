elevator pitch
  Taking the hedging risk off exchanges.
  Cutting out the middle man. Making it cheaper and more efficient and safer. 





As long as miner revenue is dominated by subsidy, powswap style pure hashrate contracts are a good protocol-centric measure of the energy of the energy cost of bitcoin. 
However, as transaction fees replace block reward over time, hashrate is less useful, particularly if fees vary significantly. 
I have proposed a protocol change that is future proof in this regard. 





Alternative definition
(Alternative definition: 
  One block: target * delta * revenue (lower numbers are a higher price)
  Multi blocks: sum(individual prices) (don't need to normalize)
I prefer the sum of prices definition because... why? 
Does it have to do with pricing around halvings? 
Maybe I should try it both ways and see which one gives nicer prices.
The current definition also has the advantage that it avoids division.)



Hashrate is difficulty target * time delta
  The lower it is, the higher the hashrate.
  Need to make sure there are no overflows. 
  Need floating point multiplication. 




Next topics.
Lightning example.






Within a 2016 block difficulty regime, the remaining blocks are more or less energetically expensive depending on how quickly they are found. This, the constantly varying hashrate, is gauged with a difficulty and a timestamp delta. 






Polemic stuff


<pre>
Todo: would it be better to measure the inverse? IE, bitcoin price of hashes? 
  Pros: energy traders care about price of energy
        harbinger of future where everything is priced in bitcoin
          Then again, if the price of bitcoin is more volatile than the price of energy, it makes more sense for now to price bitcoin in energy than the other way around.
  Cons: chart wise, it looks like inverse price of use price of bitcoin, which is what most people care about today, which is confusing
        Price is dropping hugely over time, resulting in tiny number. We could scale it up at the beginning I suppose. 
        Floating point can be used for fractions. 
</pre>

This price is a lagging measure, but over long timespans roughly corresponds to real world energy prices. 


Over long enough periods of time, the energy cost of mining a bitcoin is roughly the hashrate divided by the block reward. That is, in a given block reward regime, if the hashrate doubles, it takes twice as much energy to mine the same bitcoin. All other things between equal then, it should take half as much bitcoin to buy the same amount of energy. This is obviously not always true over short timespans, but it is true in the long run, and this fact can be used to speculate and/or hedge energy priced in bitcoin. 

So, a


these two opcodes enable a wide variety of instruments for pricing the future price of energy in bitcoin. 

In this fashion

Market forces obscure the correlation, particularly during price extremes (crashes and manias), but over a long enough time frame, the relationship holds quite well. It can be used to speculate, trade, and hedge. -- this should be its own blog post, or white paper.


Since energy is currently priced in fiat currency, one could also, albeit indirectly, speculate on the bitcoin price of fiat. 

With cheap, private, anonymous, safe difficulty speculation on chain, it is not inconceivable that one day the majority of energy trading will migrate to the bitcoin blockchain. Transaction fees generated by such an immense volume of transactions would help keep bitcoin secure as the block reward dwindles. 

More near term, on chain difficulty speculation would likely be used to attempt to fiat trade by proxy, on chain. The on chain proxy trade is inferior to what is available on centralized exchanges, in terms of tracking prices with accuracy. However, it has the benefit of being private, anonymous, and without counterparty (or oracle) risk. Many centralized fiat exchanges exit scam. Another benefit: gains are also paid directly in bitcoin, meaning reduced friction getting in and out of fiat. With low liquidity and primitive market structure, attempts to trade fiat by proxy will be of uncertain quality, but the better the liquidity the closer the on chain energy proxy will track fiat, and not just energy, prices. This reduces the need for centralized fiat exchanges, which are a serious weakness for the bitcoin ecosystem. 

That being said, centralized exchanges may also benefit from OP_BLOCKDIFFICULTY. Exchanges have first look at trades conducted on their own exchange, and this can be used for arbitraging on-chain trades that they market-make.


(difficulty) This is a unitless number, but it roughly tracks real changes in energy prices, when the pricing is done in bitcoin. So


My personal intuition is that it would be easier to build up a market around the first technique, with a joinmarket-like feel, as it composes more nicely. Ultimately the free market decides. 


Fuck! Do I need to build a floating point representation in Haskell?
  Nah! Might be fun though,. 



=== Synthetic Derivatives ===

Two ways to do this. 
1) more cases in a single output
2) build up transactions out of multiple outputs (perhaps similar to conjoin pool with makers and takers)




 by composing these simple binaries. By adding more price ticks to the synthetic futures, such compound synthetic derivatives can be made arbitrarily granular, at the expense of higher transaction costs.





https://duckduckgo.com/?q=wikipedia+binary+options&ia=web



Transactions costs themselves can be defrayed by transacting the option contracts using lightning channels. If difficulty speculation proves popular, this will grow the lightning network, which generates transaction fees for miners. There may also be privacy opportunities from combining binary markets with conjoin or other mixing protocols. 

Contract sellers with many lightning channels open can earn bitcoin by making markets. 







Centralized exchanges benefit, 
































Op_energy notes

==Motivation==

During a block subsidy regime -- that is not crossing a halving boundary -- difficulty is the price of bitcoin in energy. Difficulty target is the price of energy in bitcoin. 
The relationship is not perfectly 1 to 1, but it roughly tracks over time. If the difficulty target halves, the energy price of bitcoin doubles. And for bitcoin holders, the price of energy in bitcoin halves. (Roughly.)

This all means that making the block difficulty target visible to script makes a variety of non-custodial, non-oracle requiring, synthetic energy derivatives available for on-chain settlement between untrusting parties.

=== Cash or Nothing Binary Option on Difficulty === 

https://en.wikipedia.org/wiki/Binary_option

Alice bets Bob that the difficulty will increase at the next adjustment. Hashrate looks weak, and the adjustment is coming soon, so Bob is willing to give Alice 2 to 1 odds on that. Alice pays Bob 5,000 sat to buy the option. Bob puts 10,000 sat into a binary that matures at the next adjustment. If the difficulty rises Alice can spend it, otherwise Bob can spend it.

The binary has two outputs, which confirm as a single transaction, created collaboratively in a zero-trust way. 
Output 1: Alice pays Bob, spendable immediately by Bob.
Output 2: The binary. Spendable at maturity. To decide who wins it compares difficulty at bet time, with difficulty at maturity. 

=== Bounded Difficulty Future === 

Binaries are the atoms of op_difficulty derivatives. Synthetic futures, puts, calls, etc, can be built up from binaries. Here is an example that builds up a future, using "ticks" of binaries. 

Alice wants to buy a future from Bob. As with the binary, Bob gets paid up front, and funds the contract. The contract pays out at the maturation block. Depending on the difficulty then, the payout could go to all Alice, all Bob, or some to Alice and some to Bob. 






Current difficulty is 10 Trillion. Alice and Bob figure that the difficulty won't rise or fall by more than 20 percent, by maturity time. So the future is capped at 8T on the low end, and 12T at the high end. Alice and Bob agree on 5 ticks, at 8, 9, 10, 11 and 12T. Each of these ticks is a cash or nothing binary similar to the previous example. If the final difficulty is over 12, all of 

=== Lightning Trades === 

=== Anonymity Pools ===













If this is not the case, then a second opcode OP_DIFFICULTY_LESSTHAN is required.)


Current version bits. 
645347 (current)      171007ea
644618                17109bac



Prelude> (0x1007ea) / (0x109bac)
0.9652471270492857


(Note for reviewers: I believe difficulty targets in packed bits can be compared using the already live OP_LESSTHAN opcode

https://en.bitcoin.it/wiki/Script#Arithmetic

If this is not the case, then a second opcode OP_DIFFICULTY_LESSTHAN is required.)

op_difficulty

what is on the chain is the difficulty target. 
interesting to watch this not change in the beginning of time, and then take off when mining gets going. 





dectoHex x = Numeric.showHex x ""



let 

<let bitsToDiff exponent mantissa = 
  let target1 = ( 0x00ffff * 2**(8*(0x1d - 3)) ) 
       currentTarget =  ( mantissa * 2**(8*(exponent - 3)) )
  in  target1 / currentTarget>



Hashes = D * 2**256 / (0xffff * 2**208)
       = (target_genesis / target_current ) * ( 2**256 / (0xffff * 2**208) )
       = (target_genesis / target_current ) * ( 2**256 / target_genesis )
       = 2**256 / target_current




hashprice_block target blocktime subsidy fee = ( (2 ** 256) / target ) * ( 600 / blocktime ) / (subsidy + fee)







hashes = ( 2**256 / target_current ) * ( 600 / blocktime  )
  Need a floating point algo to give an exact number here. 
  Maybe to make it expressible 
  But let's try something simpler 






price_genesis: 

<pre>
revenue(genesis block) = ( 50 * 100,000,000 ) + 0 
blocktime = 600
hashrate = unpack(0x1d00ffff) / ( unpack(0x1d00ffff) * blocktime ) 
price = 50 * 100000000 * 600 = 3e12
</pre>





Genesis target: 0x1d00ffff
  (bx 0001 1110 0000 0000 1111 1111 1111 1111)
0x00ffff * 2**(8*(0x1d - 3))


(bx 0000 0000 1111 1111 1111 1111) * (bx 10) ** ((bx 1000) *(0x1d - (bx 1000)))






